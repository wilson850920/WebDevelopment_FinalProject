'use strict';

var module$1 = require('module');
var path = require('node:path');
var promises = require('node:fs/promises');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var path__default = /*#__PURE__*/_interopDefaultLegacy(path);

var require$1 = (
			false
				? /* @__PURE__ */ module$1.createRequire((typeof document === 'undefined' ? new (require('u' + 'rl').URL)('file:' + __filename).href : (document.currentScript && document.currentScript.src || new URL('index.js', document.baseURI).href)))
				: require
		);

function esbuildPluginPino({
  transports
}) {
  return {
    name: "pino",
    setup(currentBuild) {
      const pino = path__default["default"].dirname(require$1.resolve("pino"));
      const threadStream = path__default["default"].dirname(require$1.resolve("thread-stream"));
      let entrypoints = currentBuild.initialOptions.entryPoints;
      if (Array.isArray(entrypoints)) {
        const separator = entrypoints[0].includes("\\") ? path__default["default"].win32.sep : path__default["default"].posix.sep;
        let outbase = currentBuild.initialOptions.outbase;
        if (!outbase) {
          const hierarchy = entrypoints[0].split(separator);
          let i = 0;
          outbase = "";
          let nextOutbase = "";
          do {
            outbase = nextOutbase;
            i++;
            nextOutbase = hierarchy.slice(0, i).join(separator);
          } while (entrypoints.every((e) => e.startsWith(`${nextOutbase}${separator}`)));
        }
        const newEntrypoints = {};
        for (const entrypoint of entrypoints) {
          const destination = (outbase ? entrypoint.replace(`${outbase}${separator}`, "") : entrypoint).replace(/.(js|ts)$/, "");
          newEntrypoints[destination] = entrypoint;
        }
        entrypoints = newEntrypoints;
      }
      const customEntrypoints = {
        "thread-stream-worker": path__default["default"].join(threadStream, "lib/worker.js"),
        "pino-worker": path__default["default"].join(pino, "lib/worker.js"),
        "pino-pipeline-worker": path__default["default"].join(pino, "lib/worker-pipeline.js"),
        "pino-file": path__default["default"].join(pino, "file.js")
      };
      const transportsEntrypoints = Object.fromEntries(
        (transports || []).map((t) => [t, require$1.resolve(t)])
      );
      currentBuild.initialOptions.entryPoints = {
        ...entrypoints,
        ...customEntrypoints,
        ...transportsEntrypoints
      };
      let pinoBundlerRan = false;
      currentBuild.onEnd(() => {
        pinoBundlerRan = false;
      });
      currentBuild.onLoad({ filter: /pino\.js$/ }, async (args) => {
        if (pinoBundlerRan)
          return;
        pinoBundlerRan = true;
        const contents = await promises.readFile(args.path, "utf8");
        const absoluteOutputPath = `\${process.cwd()}\${require('path').sep}${currentBuild.initialOptions.outdir || "dist"}`;
        const functionDeclaration = `
          function pinoBundlerAbsolutePath(p) {
            try {
              return require('path').join(\`${absoluteOutputPath}\`.replace(/\\\\/g, '/'), p)
            } catch(e) {
              const f = new Function('p', 'return new URL(p, import.meta.url).pathname');
              return f(p)
            }
          }
        `;
        const pinoOverrides = Object.keys({
          ...customEntrypoints,
          ...transportsEntrypoints
        }).map(
          (id) => `'${id === "pino-file" ? "pino/file" : id}': pinoBundlerAbsolutePath('./${id}.js')`
        ).join(",");
        const globalThisDeclaration = `
          globalThis.__bundlerPathsOverrides = { ...(globalThis.__bundlerPathsOverrides || {}), ${pinoOverrides}}
        `;
        const code = functionDeclaration + globalThisDeclaration;
        return {
          contents: code + contents
        };
      });
    }
  };
}

module.exports = esbuildPluginPino;
